Vamos revisar detalhadamente todos os conceitos abordados sobre **GraphQL**, organizados por tópicos para facilitar a compreensão:

### **1. Introdução ao GraphQL**

- **O que é GraphQL?**
    - GraphQL é uma linguagem de consulta para APIs que permite aos clientes solicitarem exatamente os dados necessários, nem mais, nem menos.
    - Foi criado pelo Facebook e é uma alternativa moderna e flexível ao padrão REST.
- **Principais Operações:**
    - **Queries**: Para buscar dados.
    - **Mutations**: Para modificar dados (criar, atualizar, deletar).
    - **Subscriptions**: Para receber atualizações em tempo real.

### **2. Consultas (Queries)**

- **Objetivo:** Consultar dados do servidor de forma eficiente e personalizada.
- **Como funciona:**
    - O cliente define exatamente quais campos quer buscar.
    - Dados relacionados podem ser acessados em uma única consulta.

**Exemplo de Query:**

```
query {
  user(id: 1) {
    name
    email
  }
}
```

- **Vantagens:**
    - Menos chamadas ao servidor.
    - Evita o problema de overfetching (dados em excesso) ou underfetching (dados insuficientes).

### **3. Mutations**

- **Objetivo:** Alterar os dados no servidor, como criar, atualizar ou deletar informações.
- **Funcionamento:**
    - Mutações permitem modificar o estado da API e retornar os dados atualizados.

**Exemplo de Mutation:**

```
mutation {
  createUser(input: { name: "Diego", email: "diego@example.com" }) {
    id
    name
    email
  }
}
```

### **4. Subscriptions**

- **Objetivo:** Receber atualizações em tempo real do servidor.
- **Funcionamento:**
    - Subscriptions utilizam WebSockets para manter uma conexão aberta entre cliente e servidor.
    - Ideal para aplicações interativas, como chats e notificações.

**Exemplo de Subscription:**

```
subscription {
  newMessage {
    id
    content
    author {
      name
    }
  }
}
```

### **5. Ferramentas Populares**

- **Apollo Client**: Ferramenta robusta para integrar APIs GraphQL em aplicações front-end.
- **Express-GraphQL**: Middleware que permite criar servidores GraphQL usando o framework Express no Node.js..
- **GraphiQL**: Interface interativa para testar consultas, mutações e subscriptions.

### **6. Integração com Front-End**

- Frameworks como React e Vue.js oferecem suporte fácil a GraphQL com ferramentas como Apollo Client.
- **Apollo Client** ajuda a gerenciar consultas, mutações e cache de dados no front-end.
- Exemplo de uso de React com Apollo:

```
const GET_USERS = gql`
  query {
    users {
      id
      name
      email
    }
  }
`;

function Users() {
  const { loading, error, data } = useQuery(GET_USERS);

  if (loading) return <p>Carregando...</p>;
  if (error) return <p>Erro: {error.message}</p>;

  return (
    <ul>
      {data.users.map(user => (
        <li key={user.id}>{user.name} - {user.email}</li>
      ))}
    </ul>
  );
}
```

### **7. Integração com Bancos de Dados**

- GraphQL pode se conectar tanto a bancos **SQL** (PostgreSQL, MySQL) quanto **NoSQL** (MongoDB).
- **Exemplo com MongoDB**:

    ```
    const mongoose = require('mongoose');
    
    mongoose.connect('mongodb://localhost:27017/database', {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    
    const TodoSchema = new mongoose.Schema({
      title: String,
      completed: Boolean,
    });
    
    const Todo = mongoose.model('Todo', TodoSchema);
    ```

### **8. Escalabilidade: Schema Stitching e Federation**

- **Schema Stitching:**
    - Combina múltiplos esquemas GraphQL em um único servidor intermediário.
    - Útil para projetos legados ou simples.
- **Federation:**
    - Introduzido pela Apollo, permite criar subgráficos independentes que se combinam em um supergrafo.
    - Ideal para arquiteturas modernas, onde equipes diferentes podem gerenciar suas próprias partes da API.

### **9. Monitoramento e Versionamento**

- **Monitoramento:**
    - Ferramentas como Apollo Studio ajudam a rastrear consultas lentas, uso de esquemas e erros.
    - Logs e sistemas de rastreamento (como Datadog) fornecem visibilidade sobre a performance.
- **Versionamento:**
    - Em GraphQL, o versionamento se concentra em manter compatibilidade:
        - Campos antigos são marcados como obsoletos usando `@deprecated`.
        - Evite quebrar clientes ao introduzir novos recursos.

### **10. Cache e Otimização**

- O **cache** pode ser implementado tanto no cliente quanto no servidor:
    - **Cliente:** Apollo Client usa o `InMemoryCache` para armazenar resultados de consultas.
    - **Servidor:** Ferramentas como Redis ajudam a reduzir a carga no banco de dados.

**Exemplo no Cliente:**

```
const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache(),
});
```

### **11. Projeto Final**

- Criamos um exemplo prático de uma API GraphQL com uma lista de tarefas:
    - **Back-End:** Servidor GraphQL usando Express e MongoDB.
    - **Front-End:** Cliente React utilizando Apollo Client para consumir a API.
    - Funcionalidades: Listar, adicionar, atualizar e deletar tarefas.

Essa revisão detalhada cobre todos os conceitos principais e avançados de GraphQL que discutimos, desde fundamentos até integração com front-end e escalabilidade.

## Perguntas para aplicação prática e estudo técnico

Aqui está uma lista de perguntas práticas e técnicas para consolidar o aprendizado sobre **GraphQL** e explorar suas aplicações:

### **Conceitos Básicos**

1. O que é GraphQL e como ele difere do padrão REST?
2. Explique o que são Queries, Mutations e Subscriptions em GraphQL.
3. Quais são os benefícios de usar GraphQL em vez de REST para APIs modernas?

### **Criação de Esquemas**

4. Como você define tipos no esquema GraphQL? Dê um exemplo prático.
5. Qual a diferença entre `type`, `input` e `extend type` no GraphQL?
6. Como criar um esquema GraphQL para gerenciar uma lista de tarefas?
7. O que acontece se uma query não corresponder ao esquema do servidor?

### **Resolvers e Funcionalidades**

8. O que são resolvers no GraphQL e qual sua função em consultas e mutações?
9. Como você cria um resolver para consultar dados de um banco de dados MongoDB?
10. Explique como implementar resolvers para Subscriptions com WebSockets.
11. O que é o contexto em GraphQL e como ele é usado para passar informações entre resolvers?

### **Integração Front-End**

12. Como o Apollo Client otimiza o consumo de APIs GraphQL no front-end?
13. Explique como implementar cache no Apollo Client para melhorar o desempenho.
14. Descreva como consumir dados em uma aplicação React usando Apollo Client.
15. Como você configuraria Subscriptions no Apollo Client para receber atualizações em tempo real?

### **Escalabilidade e Integração**

16. O que é Schema Stitching e como ele combina múltiplos esquemas?
17. Explique o funcionamento do Federation e como ele permite criar um supergrafo.
18. Quais são os principais casos de uso do Federation em grandes aplicações?

### **Segurança e Monitoramento**

19. Como implementar validação de dados no esquema GraphQL?
20. Explique como implementar autenticação baseada em tokens JWT em GraphQL.
21. Quais ferramentas podem ser usadas para monitorar consultas e mutações em tempo real?
22. Como você lidaria com a depreciação de campos no esquema sem quebrar clientes existentes?

### **Banco de Dados e Persistência**

23. Como conectar resolvers GraphQL a um banco de dados PostgreSQL?
24. Descreva como usar Mongoose para interagir com MongoDB em resolvers GraphQL.
25. Qual é a diferença entre usar SQL e NoSQL com GraphQL em termos de estrutura de dados?

### **Desafios Práticos**

26. Crie uma API GraphQL simples para gerenciar produtos de um e-commerce (listar, adicionar, atualizar e deletar).
27. Como você adicionaria autenticação e autorização na API de lista de tarefas criada anteriormente?
28. Como implementar cache utilizando Redis para otimizar o desempenho de consultas?
29. Crie um esquema e resolvers para gerenciar perfis de usuários com relacionamentos entre usuários e amigos.
30. Descreva como configurar a integração de múltiplos subgráficos usando Apollo Federation.

Essas perguntas são um ótimo ponto de partida para aplicar o que foi aprendido e explorar cenários técnicos mais avançados.

