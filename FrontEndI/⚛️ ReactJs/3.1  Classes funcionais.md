O gerenciamento de estado em React varia dependendo do tipo de componente que você está utilizando: funcionais ou de classe. Vamos explorar como isso funciona em ambos os casos!

## Gerenciamento de Estado em Componentes Funcionais
Com a introdução dos Hooks no React 16.8, o gerenciamento de estado em componentes funcionais tornou-se simples e poderoso. O principal Hook para isso é o useState.

Exemplo básico com useState:
```
import React, { useState } from "react";

const ContadorFuncional = () => {
    const [contador, setContador] = useState(0); // Estado inicial é 0.

    const incrementar = () => {
        setContador(contador + 1); // Atualiza o estado.
    };

    return (
        <div>
            <p>Valor atual: {contador}</p>
            <button onClick={incrementar}>Incrementar</button>
        </div>
    );
};
```
useState inicializa o estado e fornece uma função (setContador) para atualizá-lo.
Toda vez que o estado muda, o componente é re-renderizado automaticamente.
### Vantagens dos Funcionais:
Código mais limpo e direto.
Uso de múltiplos Hooks (useEffect, useReducer, etc.) para estados complexos ou efeitos colaterais.
Melhor para componentes modernos e projetos novos.


## Gerenciamento de Estado em Componentes de Classe
Os componentes de classe utilizam o objeto state para armazenar o estado e o método setState para atualizá-lo. Este era o padrão antes da introdução dos Hooks.

Exemplo básico com state:
```
import React, { Component } from "react";

class ContadorClasse extends Component {
    state = {
        contador: 0 // Estado inicial.
    };

    incrementar = () => {
        this.setState({ contador: this.state.contador + 1 }); // Atualiza o estado.
    };

    render() {
        return (
            <div>
                <p>Valor atual: {this.state.contador}</p>
                <button onClick={this.incrementar}>Incrementar</button>
            </div>
        );
    }
}
```
Objeto state é declarado dentro do componente.
setState é usado para atualizar o estado de forma imutável, garantindo o comportamento correto.
Permite utilizar métodos de ciclo de vida como componentDidMount ou componentDidUpdate para controle adicional.
### Quando usar Classe:
Em projetos legados ou quando precisa integrar com componentes antigos.
Se for necessário usar ciclos de vida que ainda não foram substituídos por Hooks (apesar de ser raro atualmente).

## Diferenças Principais

| Característica              | Componentes Funcionais     | Componentes de Classe                          |
| --------------------------- | -------------------------- | ---------------------------------------------- |
| **Declaração**              | Função que retorna JSX     | Classe JavaScript extendendo `React.Component` |
| **Gerenciamento de Estado** | `useState` ou outros Hooks | Objeto `state` com `setState`                  |
| **Complexidade**            | Mais simples e moderno     | Estrutura mais detalhada                       |
| **Ciclo de Vida**           | Hooks (`useEffect`, etc.)  | Métodos (`componentDidMount`, etc.)            |
Hoje, componentes funcionais são a escolha recomendada, pois os Hooks substituem a maioria das funcionalidades das classes com uma sintaxe mais simples.

